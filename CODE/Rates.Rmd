---
title: "Rates"
author: "Walker Grimshaw"
date: "1/13/2020"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)

library(tidyverse)
library(readxl)
library(sf)

## Read in raw rates worksheets
Schuylkill_rates <- read_excel("./Data/Raw/bond_data/os_PA3540038_Schuylkill.xlsx",
                               sheet = "rates")
Aliquippa_rates <- read_excel("./Data/Raw/bond_data/os_PA5040006_Aliquippa.xlsx",
                              sheet = "rates")
## Johnstown's rates formatted differently than the others after 1998
Johnstown_rates <- read_excel("./Data/Raw/bond_data/os_PA4110034_Johnstown.xlsx",
                              sheet = "rates")

## Income
income_levels <- c("< 10", "10-20", "20-30", "30-40", "40-50", "50-60", "60-75",
                   "75-100", "100-125", "125-150", "150-200", "> 200")
PA_Income <- read.csv("Data/Processed/PA_Income_2017_Long.csv") %>%
  mutate(GEOID = factor(GEOID),
         Income_Range = factor(Income_Range, levels = income_levels))

```

## Inputs
```{r}
## Select Public Water System
PWS <- Schuylkill_rates

## Create income bracket cutoffs in a dataframe form that can be combined
## with the income summary data
Income_Low <- data.frame("Income_Low" = c(0, 10000, 20000, 30000, 40000, 50000, 60000,
                75000, 100000, 125000, 150000, 200000))
Income_High <- data.frame("Income_High" = c(10000, 20000, 30000, 40000, 50000, 60000,
                 75000, 100000, 125000, 150000, 200000, 1e9))
```

## Lowest Quintile Income

```{r}
## load Public Water System shapefile
PWS_PA <- 
  st_read("Data/Raw/PublicWaterSupply2019_04/PublicWaterSupply2019_04.shp") %>%
  st_transform(6346)
## Block Groups
PA_BG <- st_read("Data/Raw/tl_2017_42_bg/tl_2017_42_bg.shp") %>%
  st_transform(6346)

## Filter primary system from PWS shapefile
PWS_Primary <- filter(PWS_PA, PWS_ID == gsub("PA", "",PWS$PWSID[1]))

## Filter the block groups for those intersecting the service area

## create mask of block groups intersected by PWS_Primary
BG_Primary_Mask <- st_intersects(PA_BG, PWS_Primary, sparse = F)

## Now filter all block groups based on mask
BG_Primary <- PA_BG[BG_Primary_Mask,]

## filter Income data for block groups with GEOID %in% BG_Primary$GEOID
PA_Income_Primary <- PA_Income %>%
  filter(GEOID %in% BG_Primary$GEOID) %>%
  group_by(Income_Range) %>%
  summarize(HH_Sum = sum(Households)) %>%
  bind_cols(Income_Low, Income_High) %>%
  mutate(cumsum = cumsum(HH_Sum))
  
## Lowest Quintile Income
LQI_Percentile <- 0.2

LQI_HH_Index <- sum(PA_Income_Primary$HH_Sum)*LQI_Percentile

LQI_cumsum_Index <- detect_index(PA_Income_Primary$cumsum, function(x) x > LQI_HH_Index)

LQI <- approx(x = c(PA_Income_Primary$cumsum[LQI_cumsum_Index-1],
             PA_Income_Primary$cumsum[LQI_cumsum_Index]),
       y = c(PA_Income_Primary$Income_Low[LQI_cumsum_Index],
             PA_Income_Primary$Income_High[LQI_cumsum_Index]),
       xout = LQI_HH_Index)$y

```

## Household Size

```{r}
## For now, assume household size = 4
HH_size <- 4 # people per household
```


## Price of Basic Service

```{r}
## Monthly price of 5,000 gallons per month
## Cost = flat meter fee + minimum + volumetric fee
# conversion from gallons to cubic feet
gal_to_CF <- 0.133681

## test inputs for monthly price calculation
Volume_gal_mon <- 5000 # gallons per month

## Basic water service = 50 gal per person per day
# Volume_gal_mon <- 50*365*HH_size/12
Volume_CF_qtr <- Volume_gal_mon*3*gal_to_CF
Volume_gal_qtr <- Volume_gal_mon*3
Volume_CF_mon <- Volume_gal_mon*gal_to_CF

## Meter size for some flat rates
MeterSize <- "0.625"

## Flat portion of the price, based on the meter size
flat_price <- PWS %>%
  filter(class == MeterSize, chargeType == "Meter Size") %>%
  ## copy cost column to new columns with name "flat_cost"
  mutate(flat_cost = cost)

## Volumetric portion of the cost
volume_price <- PWS %>%
  ## filter for consumption charges and water systems, not sewer
  filter(grepl("consumption|minimum", charges, ignore.case = T),
         grepl("water", WaterSewer, ignore.case = T)) %>%
  ## first use replace to search for "over" or ">" and replace with 1e9
  ## what to do with "residential" or locations?
  mutate(class = as.numeric(replace(class,
                                    grep("over|>", class, ignore.case = T),
                                    "1000000000")),
         ## create 0 volume at cost bracket column, to be filled in for loop
         volume_at_cost = 0,
         ## create column to convert monthly costs to annual costs,
         ## changed to quarterly in for loop when the price is quarterly
         annual_conversion_factor = 12) %>%
  ## for now, remove rows with NA in class column
  drop_na(class)

## create numeric vector of unique rate years and get rid of NAs
unique_years <- as.numeric(unique(volume_price$yearSet)) %>%
  na.omit()

## tester
year <- 2009
#unique_years <- c(1990, 1991, 1995)

## initialize empty final cost dataframe, to be filled by for loop of each unique rate year
PWS_cost <- volume_price[FALSE,]

for (year in unique_years) {
  ## create new dataframe of only the year in question
  PWS_year <- filter(volume_price, yearSet == year)
  ## filter again to grab only the earliest rateYear of the current yearSet
  PWS_year <- filter(PWS_year, rateYear == first(rateYear))
  ## filter again to grab the first otherClass if otherClass is not just NAs
  ## this is in case the system has different rate structures for different parts of the service area
  if (any(!is.na(PWS_year$otherClass))) {
    PWS_year <- filter(PWS_year, otherClass == first(otherClass))
  }
                    
  ## search for gal or cf in classUnit
  CF <- any(grep("cf", PWS_year$classUnit, ignore.case = T))
  gal <- any(grepl("gal", PWS_year$classUnit, ignore.case = T))
  ## search for qtr or mon in chargeType
  quarter <- any(grepl("quarter|qtr", PWS_year$chargeType, ignore.case = T))
  month <- any(grepl("mon", PWS_year$chargeType, ignore.case = T))
  
  ## volume in correct units
  Volume <- Volume_CF_mon*CF*month + Volume_CF_qtr*CF*quarter +
    Volume_gal_mon*gal*month + Volume_gal_qtr*gal*quarter
  
  ## change annual conversion factor to 4 if the charge is quarterly
  PWS_year <- mutate(PWS_year,
                     annual_conversion_factor = case_when(quarter ~ 4,
                                                          month ~ 12))
  
  ## calculate the volume of water in each price bracket/class
  for (i in 1:length(PWS_year$class)) {
    PWS_year$volume_at_cost[i] <- max(0, min(Volume,
                                             PWS_year$class[i],
                                             Volume - PWS_year$class[i-1],
                                             PWS_year$class[i] - PWS_year$class[i-1]))
  }
  ## bind newly calculated year dataframe with existing PWS_cost dataframe
  PWS_cost <- bind_rows(PWS_cost, PWS_year)
}

## Add cost unit magnitude column, extracting price per 100 CF or 1000 gal
PWS_cost <- PWS_cost %>%
  ## change "thousand" to 1000 and "hundred" to 100
  mutate(costUnit = gsub("thousand", "1000", costUnit, ignore.case = T),
         costUnit = gsub("hundred", "100", costUnit, ignore.case = T),
         ## extract number from costUnit column
         costUnitMagnitude = as.numeric(regmatches(costUnit,
                                        gregexpr("[[:digit:]]+", costUnit))),
         ## add and calculate total_cost column,
         ## just taking cost if charges contains "minimum" or "flat"
         total_cost = case_when(grepl("minimum|flat", charges, ignore.case = T) ~ cost,
                                grepl("minimum|flat", costUnit, ignore.case = T) ~ cost,
                                TRUE ~ volume_at_cost*cost/costUnitMagnitude),
         ## add annual cost column
         annual_cost = total_cost*annual_conversion_factor
         )

## this is currently the cost per billing period
summary_cost <- PWS_cost %>%
  group_by(rateYear, yearSet) %>%
  summarize(periodic_cost = sum(total_cost),
            annual_cost = sum(annual_cost)) %>%
  group_by(yearSet) %>%
  summarize(periodic_cost = first(periodic_cost),
            annual_cost = first(annual_cost)) %>%
  ## make sure yearSet is numeric
  mutate(yearSet = as.numeric(yearSet))
  

## plot
# flat_plot <- ggplot(flat_price) +
#   geom_col(aes(x = yearSet, y = cost))
# flat_plot

volume_plot <- ggplot(summary_cost) +
  geom_col(aes(x = yearSet, y = annual_cost)) +
  labs(title = paste(PWS$name[1], " (5,000 gal)"), x = "Year Set", y = "Annual Cost (USD)")
volume_plot

## need to group by year and otherCost

###########################################
```



```{r}
## Create a function
Price <- function(PWS, Volume, MeterSize){
  flat_price <- PWS %>%
    filter(class == MeterSize, chargeType == "Meter Size")
  volume_price <- PWS %>%
    filter(charges = "Consumption Charge")
  
}

## For each year
Schuylkill_rates %>%
  filter(class = "0.625")
```

## Household Burden Indicator

```{r}
# Cost of basic water service as percentage of lowest quintile income

```

## Poverty Prevalence Indicator

```{r}
# Percent of community households below 200% FPL
FPL_2017 <- c(12060, 16240, 20420, 24600, 28780, 32960, 37140, 41320)
FPL200_PWS <- 2*FPL_2000[HH_size]
```

